[{"content":"Los aniversarios, puede ser un cumplea√±os, fin a√±o o cualquiera sea, en general lo llevan a uno llevan a reflexionar.\nEste caso no ser√≠a la excepci√≥n, ¬øcu√°l es el aniversario?, hace menos de un mes cumpl√≠ un a√±o en mi actual empresa (Pomelo), el 29 de agosto del 2022 hicieron p√∫blicas las promociones en la empresa, formo parte de las personas a las que ascendieron, quer√≠a escribir algunas conclusiones que me llevo de estos m√°s 365 d√≠as, dos equipos y un ascenso.\nPilares Los que me conocen, sea en lo laboral o la vida personal, me escuchan hablar sobre tres principios, con los que trato de movilizarme y busco a mi alrededor:\nConfianza Humildad Respeto Confianza Voy a intentar explicar que significa para m√≠ este pilar.\nEn una de mis primeras publicaciones donde hablo sobre errores y aprendizajes, hablo sobre que ascender no deber√≠a ser la √∫nica o principal meta hay cosas much√≠simo, pero much√≠simo m√°s importantes y la confianza es una de ellas.\nOk luispi, ¬øpero qu√© tiene que ver con la confianza?, alla vamos.\nInicios Mi primer acercamiento a Pomelo fu√© por medio de Maru, ya nos conoc√≠amos, Maru fu√© quien hizo el proceso de hiring cuando entr√© en MercadoLibre, luego estuvimos cerca de reencontrarnos en Naranja X, pero bien sirvi√≥ el impasse para reencontrarnos profesionalmente en Pomelo, esto lo cuento justamente por el t√©rmino de confianza.\n¬øCreen que Maru hubiese confiado en m√≠ no solo una, sino dos veces?, yo creo que no, es una persona absolutamente admirable en construir equipos de tecnolog√≠a, y esa confianza que mutuamente nos tenemos hace que:\nMaru vuelva a confiar en m√≠ una y otra vez y vuelva a convocarme. De mi lado tomar esa confianza depositada y construir (o intentar hacerlo) el mejor contexto de trabajo posible. Reencuentro y desencuentro En los m√°s 365 d√≠as que llevo en Pomelo trabaje casi la mitad de tiempo en el equipo del Procesador, me reencontr√© con caras conocidas y conoc√≠ algunas nuevas, ya voy a nombrarlas, primero la an√©cdota.\nEn el Procesador estuve poco m√°s de 5 meses, cumplimos el hito (locura) de tener en marcha el procesador y luego mediando enero de 2022 me mude al equipo de infra. Ac√° se jugaron dos pilares, confianza y respeto, ¬øpor qu√© digo esto?, los chicos supieron para donde quer√≠a dirigir mi carrera y me apoyaron al 100%.\nNo obstante 7 meses despu√©s me demostraron que son personas en las cuales voy a confiar infinitamente m√°s all√° de Pomelo, estas personas son: Brizi, Dami y Nico, no voy a contar los pormenores ellos saben a qu√© me refiero, pero quer√≠a agradecerles p√∫blicamente ‚ù§Ô∏è.\nCon ustedes, a la guerra con un escarbadientes Habl√© de mi primera etapa en Pomelo, pasemos a la segunda, \u0026ldquo;Migraci√≥n al equipo de Infraestructura\u0026rdquo;.\nDe enero a esta parte y desde el minuto cero Juanjo, Fede y Gus y conoci√©ndome, dir√≠a que nada, me dieron el espacio para crear un espacio de debates y repreguntas. Escucharon mis propuestas, las hicieron suyas, y entre todos las llevamos adelante, me hicieron partes de las suyas las tome como propias y as√≠ rodeado de una pila de personas con una calidad humana de otro planeta hicimos y estamos haciendo cosas incre√≠bles.\n¬øCu√°l es el punto de todo esto?, que ascender no sea la principal o √∫nica meta, generar confianza a tu alrededor es incontable de veces m√°s importante y es, al menos en los valores que persigo y busco, infinitamente superior a cualquier puesto que ocupemos u obtengamos.\nPor ahora no quiero aburrir ni extenderme, pronto voy a escribir sobre los otros dos pilares que siento indispensables para transitar la vida, humildad y respeto.\n","permalink":"https://luispe.github.io/blog/es/posts/career/","summary":"Los aniversarios, puede ser un cumplea√±os, fin a√±o o cualquiera sea, en general lo llevan a uno llevan a reflexionar.\nEste caso no ser√≠a la excepci√≥n, ¬øcu√°l es el aniversario?, hace menos de un mes cumpl√≠ un a√±o en mi actual empresa (Pomelo), el 29 de agosto del 2022 hicieron p√∫blicas las promociones en la empresa, formo parte de las personas a las que ascendieron, quer√≠a escribir algunas conclusiones que me llevo de estos m√°s 365 d√≠as, dos equipos y un ascenso.","title":"Aniversarios"},{"content":"En la siguiente publicaci√≥n vamos a repensar un concepto com√∫nmente encontrado y avalado en la industria de la tecnolog√≠a, la deuda t√©cnica.\nDistinta vara Imaginemos que necesitamos pintar el exterior de nuestra casa y decidimos contratar a un profesional para que realice el trabajo.\nDespu√©s de consultar por varios presupuestos decidimos contratar los servicios de \u0026ldquo;x\u0026rdquo; para que se encargue del trabajo.\nAl cabo de unos dias \u0026ldquo;x\u0026rdquo; nos comenta:\n- El trabajo est√° terminado.\nNos paramos en el frente de la casa y notamos que alrededor de los marcos de la ventana no est√° pintado en algunos casos.\nAl notar esto le preguntamos a \u0026ldquo;x\u0026rdquo; porque no pinto alrededor de los marcos de la ventana, a lo que nos responde:\n- Disculpe, es una deuda t√©cnica que la podemos atacar a futuro.\n¬øQu√© sentir√≠as si te encontr√°s con una situaci√≥n asi?\n¬øPor qu√© en el contexto de la tecnolog√≠a avalamos tener deuda t√©cnica?\nRepensemos En tecnolog√≠a es muy com√∫n encontrarnos con este escenario y lamentablemente lo naturalizamos y como comente en una publicaci√≥n anterior donde hablo entre otras cosas sobre la importancia de documentar y hacer test, es algo com√∫n que siempre veo como \u0026ldquo;deuda t√©cnica\u0026rdquo;, repensando en el ejemplo de pintar la casa creo que nos expone como podemos tener \u0026ldquo;distinta vara\u0026rdquo; para medir la misma situaci√≥n en diferentes contextos.\n¬øPor qu√© es nociva la deuda t√©cnica?\nEn contexto de tests: es extremadamente dif√≠cil realizar cambios sin que explote todo. En contexto de documentaci√≥n: es extremadamente dif√≠cil agregar funcionalidad porque la falta de documentaci√≥n hace que perdamos una cantidad enorme de tiempo tratando de entender como est√°n construidas las cosas. En contexto de equipo: tener deuda t√©cnica hace que el conocimiento quede en las personas y deber√≠amos siempre, siempre, impulsar que el conocimiento est√© distribuido. Conclusiones La deuda t√©cnica es muy agotadora para los equipos y donde hoy pensamos que estamos ganando tiempo te aseguro que pronto, muy pronto, se pierde agilidad y velocidad en el desarrollo.\nSe puede evitar en la mayor√≠a de los casos y no la aceptemos como algo natural.\nPara finalizar espero que repensemos juntos la \u0026ldquo;deuda t√©cnica\u0026rdquo; y que nos incomode tenerla.\n¬°Gracias por leerme! üëãüèΩ\n","permalink":"https://luispe.github.io/blog/es/posts/technical-debt/","summary":"En la siguiente publicaci√≥n vamos a repensar un concepto com√∫nmente encontrado y avalado en la industria de la tecnolog√≠a, la deuda t√©cnica.\nDistinta vara Imaginemos que necesitamos pintar el exterior de nuestra casa y decidimos contratar a un profesional para que realice el trabajo.\nDespu√©s de consultar por varios presupuestos decidimos contratar los servicios de \u0026ldquo;x\u0026rdquo; para que se encargue del trabajo.\nAl cabo de unos dias \u0026ldquo;x\u0026rdquo; nos comenta:","title":"Deuda t√©cnica"},{"content":"En la siguiente publicaci√≥n quiero compartir un error com√∫n que sol√≠a cometer en mis proyectos en Golang. Y como bien dice el t√≠tulo y descripci√≥n hoy vamos a hablar de las interfaces.\nSeguramente se encuentren con algunas referencias a otra publicaci√≥n que hice sobre arquitectura hexagonal, creo que parte del mal uso de las interfaces es la consecuencia de seguir a rajatabla publicaciones de \u0026ldquo;medium\u0026rdquo; y no tomarse el tiempo para entender el concepto subyacente.\nPre√°mbulo Si hay algo que tenemos que admitir en el ecosistema de Golang es el enrosque que a veces nos damos con algunas/varias cuestiones. Por dar un ejemplo en como nombrar las variables (que es un tema del que quiero hablar pronto) y en el caso de hoy con las interfaces.\nGolang tiene sus particularidades, pero se basa en muchos patrones ya conocidos en la industria. En el ecosistema de Go a veces complejizamos algunos patrones y caemos en \u0026ldquo;anti patrones\u0026rdquo;, en la siguiente publicaci√≥n vamos a revisar un proyecto falso y refactorizarlo para hacer un buen uso de las interfaces.\nPara simplificar un poco la publicaci√≥n vamos a acotar el caso de uso y lo reduciremos a la capa de servicio y repositorio.\nImaginemos que en la capa de repositorio nos encontramos con lo siguiente:\npackage repository import ( // pkg imports ) type Repository interface { Save(ctx context.Context, model *beer.Beer) (*beer.Beer, error) } type repository struct { // repository client and configs go here } func NewRepository() Repository { return \u0026amp;repository{} } func (repo *repository) Save(ctx context.Context, model *beer.Beer) (*beer.Beer, error) { // previous logic here return repo.toModel(beerEntity), nil } Y en la capa de servicio lo siguiente:\npackage service import ( // pkg imports ) type Service interface { Create(ctx context.Context, model *Beer) (*Beer, error) } type service struct { repo Repository } func NewService(repo Repository) Service { return \u0026amp;service{repo: repo} } func (svc *service) Create(ctx context.Context, model *Beer) (*Beer, error) { beer, err := svc.repo.Save(ctx, model) if err != nil { return nil, err } return beer, err } El anterior escenario es el que me encuentro com√∫nmente en los proyectos de Go y quiero comentarles que yo tambi√©n supe cometer el mismo error.\nTodo bien luispi, ¬øpero cu√°l es el error?\nLas interfaces Go generalmente pertenecen al paquete que usa valores del tipo de interfaz, no al paquete que implementa esos valores. üôÄ üí•\nPropuesta/aprendizaje El paquete de implementaci√≥n debe devolver tipos concretos (generalmente puntero o estructura): de esa manera, se pueden agregar nuevos m√©todos a las implementaciones sin requerir una refactorizaci√≥n extensa.\nCon esto en mente vayamos a los bifes\nEn primer lugar ataquemos la capa de repositorio, como bien dice la nota anterior vamos a retornar una estructura y no la interfaz.\npackage repository import ( // pkg imports ) type Repository struct{ // repository client and configs go here } func NewRepository() Repository { return Repository{} } func (repo *Repository) Save(ctx context.Context, model *beer.Beer) (*beer.Beer, error) { // previous logic here return repo.toModel(beerEntity), nil } Repasemos el cambio.\nEn primer lugar, eliminamos la interfaz y ahora la funci√≥n NewRepository() retorna la estructura Repository, y en segundo lugar agregamos a Repository el m√©todo save.\nTodo bien luispi, ¬øpero qu√© ganamos con este cambio?\nComo no tenemos que cumplir con ning√∫n contrato de interfaz no estamos atados a tener que implementar todos los m√©todos que tenga la misma.\nTenemos que pensar a este paquete como un productor (producer) y siempre tengamos como nota mental que los producer, de nuevo, retornan tipos concretos (generalmente un puntero o una estructura).\nAhora es el turno de editar la capa del consumidor (consumer), en este caso el service.\npackage service import ( // pkg imports ) type Repository interface { Save(ctx context.Context, beer *Beer) (*Beer, error) } type Service struct { repo Repository } func NewService(repo Repository) Service { return Service{repo: repo} } func (svc *Service) Create(ctx context.Context, beer *Beer) (*Beer, error) { createBeer, err := svc.repo.Save(ctx, beer) if err != nil { return nil, err } return createBeer, err } Repasemos el cambio.\nRealizamos varios cambios, en primer lugar declaramos la interfaz Repository y en la estructura Service inyectamos la interfaz para que pueda consumirse en los m√©todos del servicio.\nAl igual que con la capa de repositorio nuestro NewService() ahora retorna una estructura y no una interfaz.\nPor ultimo agregamos el m√©todo Create a nuestro Service.\nConclusiones Con estos cambios sutiles pero poderosos nuestros producer ahora tienen una enorme flexibilidad.\nPor √∫ltimo quiero agradecer a mi amigo y mentor morenojp que me comparti√≥ este anti patr√≥n y me hizo repensar y mejorar, una vez m√°s, en esto del desarrollo de software.\nPara no aburrirte y por el momento hagamos una pausa.\nPr√≥ximamente vamos a seguir con peque√±as publicaciones donde vamos a intentar repensar otros anti patrones.\n¬°Que pase bien!\nFuentes:\nwiki oficial de Golang go interfaces misuse ","permalink":"https://luispe.github.io/blog/es/posts/interfaces-correct-use/","summary":"En la siguiente publicaci√≥n quiero compartir un error com√∫n que sol√≠a cometer en mis proyectos en Golang. Y como bien dice el t√≠tulo y descripci√≥n hoy vamos a hablar de las interfaces.\nSeguramente se encuentren con algunas referencias a otra publicaci√≥n que hice sobre arquitectura hexagonal, creo que parte del mal uso de las interfaces es la consecuencia de seguir a rajatabla publicaciones de \u0026ldquo;medium\u0026rdquo; y no tomarse el tiempo para entender el concepto subyacente.","title":"Interfaces y \"copy paste\""},{"content":"La siguiente publicaci√≥n se podr√≠a decir que es una continuaci√≥n de otra donde hablamos de como tener im√°genes livianas nos ayuda en muchos aspectos, si a√∫n no pudiste leerla ac√° te dejo el acceso.\nHoy vamos a realizar una peque√±a, pero importante mejora, y vamos a descubrir porque la estamos realizando.\nPre√°mbulo Como √∫ltima propuesta en la publicaci√≥n que compart√≠ anteriormente nos quedamos en este punto:\n# First layer use to build a Golang binary FROM golang:1.18-alpine3.16 AS builder WORKDIR /build COPY go.mod go.sum ./ RUN go mod download \u0026amp;\u0026amp; go mod verify COPY . ./ RUN GOOS=linux go build -o ./myapp ./path/to/main # Final layer expose app to minimal docker image FROM alpine:3.16.0 COPY --from=builder /build/myapp /myapp ENTRYPOINT [\u0026#34;/myapp\u0026#34;] Si tenemos como premisa que la tecnolog√≠a de containers y su popularizaci√≥n con Docker es disruptiva es en gran medida por los beneficios de poder construir en diferentes lugares y no encontrarnos con sorpresas cuando iniciamos la aplicaci√≥n que est√° contenida en el container, te invito a que pensemos durante unos segundos/minutos o el tiempo que necesitemos.\n¬øSe puede realizar una mejora en la imagen para la aplicaci√≥n de Golang?\nLa respuesta es si, ¬°manos a la obra!\nPropuesta/aprendizaje Golang posee una caracter√≠stica que es realmente poderosa, y no estoy hablando de las goroutines, y es la gran virtud de poder realizar compilaci√≥n cruzada.\n¬øQu√© es compilaci√≥n cruzada?, es la caracter√≠stica de poder compilar desde un host con una determinada arquitectura y sistema operativo (SO) el binario para otra arquitectura o SO.\nEntonces para ser un poco m√°s espec√≠ficos podemos desde un host con SO = linux y arquitectura = amd64, compilar un binario para SO = windows, arquitectura = 386 üî•.\nImaginemos ahora que donde corremos los contenedores para nuestras aplicaciones el c√≥mputo es linux como SO y con arquitectura amd64.\nCon esto en mente realicemos una peque√±a, pero importante mejora en nuestro Dockerfile.\n# First layer use to build a Golang binary FROM golang:1.18-alpine3.16 AS builder WORKDIR /build COPY go.mod go.sum ./ RUN go mod download \u0026amp;\u0026amp; go mod verify ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 COPY . ./ RUN go build -o ./myapp ./path/to/main # Final layer expose app to minimal docker image FROM alpine:3.16.0 COPY --from=builder /build/myapp /myapp ENTRYPOINT [\u0026#34;/myapp\u0026#34;] Primero analicemos el cambio y porque lo realizamos.\nENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 CGO_ENABLED=0 desactivamos CGO\nGOARCH=amd64 indicamos la arquitectura\nGOOS=linux indicamos el SO\nTodo bien luispi, ¬øpero qu√© ganancia obtuvimos?\nAsegurarnos de compilar la aplicaci√≥n para el entorno en el que va a ser ejecutado nos va a prevenir varios dolores de cabeza o \u0026ldquo;troubleshooting\u0026rdquo;, y de m√°s esta decir que ya no nos importa donde vamos a hacerlo (cualquiera sea nuestro canal de integraci√≥n continua), porque realizando la compilaci√≥n, de nuevo, para el entorno en que va a ser ejecutado, nos quedamos tranquilos de que estamos acortando el margen de contratiempos.\nPara no aburrirte y por el momento hagamos una pausa.\n¬°Que pase bien! üëãüèΩ\n","permalink":"https://luispe.github.io/blog/es/posts/when-the-context-matter/","summary":"La siguiente publicaci√≥n se podr√≠a decir que es una continuaci√≥n de otra donde hablamos de como tener im√°genes livianas nos ayuda en muchos aspectos, si a√∫n no pudiste leerla ac√° te dejo el acceso.\nHoy vamos a realizar una peque√±a, pero importante mejora, y vamos a descubrir porque la estamos realizando.\nPre√°mbulo Como √∫ltima propuesta en la publicaci√≥n que compart√≠ anteriormente nos quedamos en este punto:\n# First layer use to build a Golang binary FROM golang:1.","title":"Cuando el contexto importa"},{"content":"En la siguiente publicaci√≥n voy a compartirles algunos consejos y buenas pr√°cticas para desarrollar nuestras im√°genes de container, como ejemplo vamos a crear una imagen para una app en Golang, pero los siguientes consejos aplican para cualquier lenguaje, ¬°vamos!\nPre√°mbulo Perseguir que nuestras im√°genes de container sean lo m√°s reducida posible en cuanto a su peso (megabytes, gigabytes, etc) no es una cuesti√≥n de gustos, nos ayuda en muchos aspectos, a continuaci√≥n les comparto algunos:\nReduce gastos de storage en el registry que utilizamos para gestionar nuestras im√°genes. Cuando tengamos que obtener la imagen para iniciar el container queda claro que mientras m√°s liviana sea m√°s r√°pido va a ser la inicializaci√≥n del container, y con esto ganamos en dos puntos. Costos, y con costos nos referimos al uso del networking que utilicemos para obtener la imagen y luego inicializar el container. Velocidad en auto scaling, est√° claro que obtener una imagen de 20 MB versus una de 900 MB la primera, claro est√°, va a inicializarse con mayor velocidad. Por dar algunos ejemplos.\nComencemos Imaginemos que tenemos el siguiente Dockerfile para crear nuestra imagen de container e.g:\nFROM golang:1.18 WORKDIR /build COPY go.mod go.sum ./ RUN go mod download \u0026amp;\u0026amp; go mod verify COPY . ./ RUN go build -o ./myapp ./path/to/main ENTRYPOINT [\u0026#34;/myapp\u0026#34;] Construyamos nuestra imagen docker build -t myapp:0.0.1 .\nSi listamos las im√°genes que tengamos en nuestro host vamos a poder observar que el peso es de aproximadamente 968 MB\nWhat? 968 MB solo para disponibilizar un binario que pesa unos pocos megas?\nNOTA\nEn todas mis publicaciones vas a encontrarte con conceptos, la idea es que aprendamos y no copiemos y peguemos. Por dar un ejemplo RUN go build -o ./myapp ./path/to/main donde ./path/to/main deber√≠a estar el main de tu app de Golang\nPropuesta/aprendizaje Vamos con la primera propuesta. Siempre es una buena pr√°ctica usar im√°genes -alpine, por convenci√≥n en el universo de container cuando disponibilizamos una imagen -alpine estamos indicando al cliente que es una imagen reducida en tama√±o y la que deber√≠amos utilizar en nuestro Dockerfile, entre otras cosas.\nBien, realicemos un peque√±o cambio en nuestro Dockerfile y volvamos a construir nuestra imagen\nFROM golang:1.18-alpine3.16 WORKDIR /build COPY go.mod go.sum ./ RUN go mod download \u0026amp;\u0026amp; go mod verify COPY . ./ RUN go build -o ./myapp ./path/to/main ENTRYPOINT [\u0026#34;/myapp\u0026#34;] Si prestamos atenci√≥n el cambio fue sutil, pero efectivo, pasamos de FROM golang:1.18 a FROM golang:1.18-alpine3.16\nConstruyamos nuevamente nuestra imagen docker build -t myapp:0.0.2 .\nSi volvemos a listar las im√°genes nos vamos a encontrar con que ahora la imagen myapp:0.0.2 pesa aproximadamente 331 MB\nReducimos, si las cuentas no fallan, 637 MB.\nEs una excelente \u0026ldquo;approach\u0026rdquo; pero repensemos. ¬øHace falta tener una imagen con todo Golang dentro del container pesando cerca de 331 MB para disponibilizar un binario que pesa unos cuantos megabytes?.\nLa respuesta es claramente, no.\nSegunda propuesta La tecnolog√≠a de container tiene una caracter√≠stica excelente, que para nuestro caso, nos va a ayudar a construir una imagen de container muy liviana, por si no lo sab√≠as, estoy hablando de Multistage, te comparto la documentaci√≥n oficial para que profundices sobre esta caracter√≠stica.\n¬øEn qu√© consiste Multistage?, se trata de construir im√°genes por etapas pudiendo as√≠ compartir datos entre cada una de ellas y vamos a obtener una imagen final de un tama√±o muy peque√±o.\nLo primero que vamos a hacer es tener una primera etapa de build, donde vamos a construir el binario, y una segunda etapa donde vamos a dejarlo disponible para utilizarlo.\nManos a la obra, abramos y realicemos las siguientes modificaciones a nuestro Dockerfile.\n# First layer use to build a Golang binary FROM golang:1.18-alpine3.16 AS builder WORKDIR /build COPY go.mod go.sum ./ RUN go mod download \u0026amp;\u0026amp; go mod verify COPY . ./ RUN go build -o ./myapp ./path/to/main # Final layer expose app to minimal docker image FROM alpine:3.16.0 COPY --from=builder /build/myapp /myapp ENTRYPOINT [\u0026#34;/myapp\u0026#34;] Como podemos observar la primera modificaci√≥n consiste en taguear la primera etapa como build. Luego en la segunda y etapa final con la siguiente l√≠nea COPY --from=builder /build/myapp /myapp copiamos el binario desde la etapa que tagueamos como builder y lo disponibilizamos en una imagen alpine.\nSi listamos ahora nuestras im√°genes podemos observar que pesa aproximadamente 9 MB, si si, escribi correctamente 9 megabytes üòé.\nPodr√≠amos realizar una √∫ltima optimizaci√≥n o buena pr√°ctica, pero creo que vale la pena dejarlo para otra publicaci√≥n.\nPara no aburrirte y por el momento hagamos una pausa.\n¬°Que pase bien!\n","permalink":"https://luispe.github.io/blog/es/posts/lightweight-container-image/","summary":"En la siguiente publicaci√≥n voy a compartirles algunos consejos y buenas pr√°cticas para desarrollar nuestras im√°genes de container, como ejemplo vamos a crear una imagen para una app en Golang, pero los siguientes consejos aplican para cualquier lenguaje, ¬°vamos!\nPre√°mbulo Perseguir que nuestras im√°genes de container sean lo m√°s reducida posible en cuanto a su peso (megabytes, gigabytes, etc) no es una cuesti√≥n de gustos, nos ayuda en muchos aspectos, a continuaci√≥n les comparto algunos:","title":"El tama√±o importa"},{"content":"Esta es la primera de una serie donde vamos a revisar diferentes patrones de desarrollo que errores comet√≠ y cu√°l es en la actualidad y lo que entiendo hasta el momento, la mejor forma de aplicarlo.\nComo bien dice el t√≠tulo de la publicaci√≥n hoy quiero hablar sobre arquitectura hexagonal.\nPre√°mbulo Hace tiempo noto mucho \u0026ldquo;hype\u0026rdquo; en torno a la arquitectura hexagonal y me gustar√≠a ser claro al respecto, no estoy en contra, mas bien todo lo contrario, me parece un excelente patr√≥n.\nPero creo que caemos en el error de aplicar la recetas de publicaciones de \u0026ldquo;medium\u0026rdquo; y no solo terminamos con todas las capas de nuestro sistema acopladas sino que con nombres de packages al estilo \u0026ldquo;adapters\u0026rdquo; o \u0026ldquo;ports\u0026rdquo; y si hay algo hermoso en el lenguaje de Go(lang) es la intencionalidad en el nombre de un package.\nUn buen nombre en el package hace que casi ni sea necesario nada m√°s para expresar la intencionalidad del mismo.\nTe comparto y recomiendo leer la siguiente publicaci√≥n oficial, opini√≥n personal, aplica para cualquier lenguaje.\nComencemos Anti patr√≥n\nAnotaci√≥n en nuestro modelo de dominio e.g json\nUn error que sol√≠a cometer es tener las anotaciones json o gorm o cualquier anotaci√≥n en el modelo de dominio.\nImaginemos que tenemos nuestro modelo /user/user.go con el siguiente contenido\ntype User struct { FirstName string `json:\u0026#34;first_name\u0026#34;` LastName string `json:\u0026#34;last_name\u0026#34;` } Antes de continuar leyendo te invito a que por unos segundos/minutos hagamos una reflexi√≥n de porque es un anti patr√≥n.\nPropuesta/aprendizaje Nuestro modelo deber√≠a ser agn√≥stico a la capa de presentaci√≥n y a la de datos, por lo tanto, no deber√≠a contener ninguna anotaci√≥n. Deber√≠amos mapear los datos hacia nuestro modelo y viceversa, a continuaci√≥n un ejemplo de como quedar√≠a un controlador rest HTTP e.g.:\nuser/rest_controller.go\ntype UserDTO struct { FirstName string `json:\u0026#34;first_name\u0026#34;` LastName string `json:\u0026#34;last_name\u0026#34;` } func (ctrl *controller) toUserModel(userDTO *UserDTO) *User { return \u0026amp;User{ FirstName:\tuserDTO.FirstName, LastName:\tuserDTO.LastName, } } func (ctrl *controller) toUserDTO(user *User) *UserDTO { return \u0026amp;UserDTO{ FirstName:\tuser.FirstName, LastName:\tuser.LastName, } } Como podemos ver en el ejemplo anterior los metodos privados en el controlador rest mapean desde el data transfer object hacia el modelo de dominio cuando llamemos al servicio y viceversa.\nPor √∫ltimo quitamos las anotaciones en nuestro modelo user/user.go\ntype User struct { FirstName string LastName string } Todo bien luispi, ¬øpero qu√© ganancia obtuvimos?\nAhora nuestro /user/user.go al no tener ninguna anotaci√≥n no importa como presentemos o como obtengamos/persistamos los datos, nunca vamos a tocar el core/dominio de nuestra aplicaci√≥n, ahora si podr√≠amos afirmar que nuestro core/dominio es agn√≥stico a las capas de presentaci√≥n o datos ganando flexibilidad, testabilidad, etc.\nPara no aburrirte y por el momento hagamos una pausa.\nPr√≥ximamente vamos a seguir con peque√±as publicaciones donde vamos a intentar repensar otros anti patrones.\n¬°Que pase bien!\n","permalink":"https://luispe.github.io/blog/es/posts/hexagonal-architecture/","summary":"Esta es la primera de una serie donde vamos a revisar diferentes patrones de desarrollo que errores comet√≠ y cu√°l es en la actualidad y lo que entiendo hasta el momento, la mejor forma de aplicarlo.\nComo bien dice el t√≠tulo de la publicaci√≥n hoy quiero hablar sobre arquitectura hexagonal.\nPre√°mbulo Hace tiempo noto mucho \u0026ldquo;hype\u0026rdquo; en torno a la arquitectura hexagonal y me gustar√≠a ser claro al respecto, no estoy en contra, mas bien todo lo contrario, me parece un excelente patr√≥n.","title":"Hexagonal Architecture"},{"content":"En nuestra sociedad en general y en tecnolog√≠a en particular tenemos la extra√±a costumbre de publicar los aciertos (opini√≥n de quien redacta, mal llamado caso de √©xito) y pocas, por no decir nulas, las ocasiones donde se comparten los errores (opini√≥n de quien redacta, mal llamado fracaso).\nComo estar√°s sospechando a continuaci√≥n voy a compartir algunos errores, que aprend√≠ de ellos y m√°s a√∫n cuanto crec√≠ y entend√≠ de la industria al compartirlos.\nEnse√±anza 1: Escribir un paso a paso, compartirlo, validarlo y re-validarlo antes de ejecutar nada\nMi primer desarrollo productivo fue en 2012 (?) aproximadamente, se trat√≥ de una web para una empresa que necesitaba publicar su cat√°logo de productos, enumero tecnolog√≠as para tener un poco de contexto:\ndigitalocean, reci√©n salido, adem√°s de los droplets no se cuantos productos m√°s ten√≠a en cartera angular js (angular 1) creo que nodeJS para el backend Este desarrollo lo hice con quien es una de las personas que m√°s respeto y admiro, V√≠ctor De Grandis ‚ÄìVitor‚Äì.\nMi experiencia configurando servidores era nula, tuve la delirante idea de decirle a Vitor:\nche amigo, ¬øpuedo configurar el servidor y despu√©s intentas romperlo?\nActo seguido me pongo a realizar varias configuraciones entre ellas me puse a jugar con los puertos, hasta que muy orgulloso le digo:\nVitor, prob√° a ver qu√© onda\nDespu√©s de un rato me llega un mensaje,\namigo ¬øpuede ser que cerraste el puerto 22?\nHermoso, sal√≠ de la casa, cerr√© la puerta y tir√© la llave a una laguna.\nComo la gente de digitalocean est√° preparada para personas como quien redacta, tiene una funcionalidad que si se accede desde la web (no tengo mucha idea como se resuelve por detr√°s) podes ejecutar una terminal en el navegador y acceder al droplet.\nConfigure de nuevo los puertos, y el resto medio que es historia.\nEnse√±anza 2: Documentar el conocimiento por m√°s trivial que lo consideremo e invitemos a que el resto lo haga. Adem√°s de evitar varias reuniones de ‚Äútransferencia de conocimiento‚Äù nos vamos a ahorrar varios arrobas, ¬øte recuerda algo?\n@fulanito puede darte una mano\nEn otro equipo que tuve la fortuna de trabajar, peque√±o en cantidad de personas pero de las cuales aprend√≠ mucho mucho de cada una de ellas, lamentablemente la aventura fue muy corta en tiempo.\nLo que s√≠ me extra√±√≥ mucho a medida que uno a uno se iba yendo gente del equipo es que perd√≠amos mucho conocimiento a punto tal de parar motores (literal) y estar semanas sin entregar funcionalidades a producci√≥n porque tuvimos que sentarnos a entender c√≥mo dejar esa l√≠nea de c√≥digo local y exponerla a internet.\n¬øQu√© errores detecte y que aprend√≠?\nDocumentar el conocimiento, por m√°s trivial que lo consideremos, documentarlo.\nO acaso, y te invito a pensar durante unos segundos. ¬øte encontraste una o m√°s veces haciendo reuniones de ‚Äúknowledge transfer‚Äù porque alguna persona estaba dejando el equipo?\n¬øo acaso eras vos quien lo estaba dejando?\nEnse√±anza 3: Ascender no deber√≠a ser la √∫nica o principal meta, compartir y adquirir conocimiento deber√≠a ser la gu√≠a.\nEnse√±anza 3 bis:\nPensar y realizar pruebas antes de implementar cualquier cosa es una gu√≠a fundamental para entender el comportamiento de nuestros sistemas o del conocimiento del dominio que tenemos hasta el momento. Siempre y repitamos, siempre, es una ganancia en el tiempo.\nPor √∫ltimo y en otro lugar que trabaj√©, conoc√≠ a una de las personas que mejor resuelve problemas, Juan Moreno, ¬øqu√© es mejor para m√≠?, soluciones simples a problemas complejos.\nDespu√©s de este peque√±o par√©ntesis y dedicatoria a quien hoy es una de mis fuentes de consulta, voy a intentar explicar la ense√±anza n√∫mero 3 y 3 bis.\nEn los tiempos pre pandemia, sol√≠a ‚Äìcostumbre que aun conservo desde lo remoto‚Äì arrancar temprano, tener un par de horas ‚Äúa solas‚Äù me permite focalizar y priorizar en la medida de lo posible las cosas que quiero y me compromet√≠ a realizar.\nUna de esas ma√±anas y en consecuencia a una funcionalidad que est√°bamos desarrollando en el equipo el l√≠der lleg√≥ un poco enojado (por ser amable) y agarr√≥ a los primeros que encontr√≥ del equipo, pudiendo as√≠ descargar su enojo porque hab√≠a ‚Äúquedado mal‚Äù ante sus superiores porque de todas las casu√≠sticas hab√≠a un caso que romp√≠a.\nFamoso Take a breath y al cabo de unos minutos me junte con √©l a solas, le hice una pregunta:\n¬øcu√°ntas personas est√°n involucradas en esta funcionalidad?\nEntendi√≥ con la pregunta que deb√≠a haber esperado y comentarle a todo el equipo responsable lo que hab√≠a pasado y no agarrar a los primero que se cruz√≥ en el camino.\nPor √∫ltimo le dije que comprend√≠a pero no compart√≠a su enojo ni como lo hab√≠a manejado.\nQuiero aclarar que mi intenci√≥n no es juzgar, sino compartir que aprend√≠ de ese error, de nuevo:\nAscender no deber√≠a ser la √∫nica o principal meta, se corre el riesgo de estar bajo una enorme presi√≥n por no estar a la altura de las circunstancias. Compartir y adquirir conocimiento deber√≠a ser la gu√≠a.\nPensar y realizar test antes de implementar cualquier cosa es la gu√≠a fundamental para entender el comportamiento de nuestros sistemas o del conocimiento del dominio que tenemos hasta el momento. Siempre y repitamos, siempre, es una ganancia en el tiempo.\nPara finalizar entiendo que voy a seguir cometiendo errores y compartiendo la experiencia que me dejaron, eso no me hace ni peor ni mejor que nadie.\nEstoy convencido que es una sana manera de transitar la vida donde lo ‚Äúnormal‚Äù es mostrarnos ‚Äúexitosos‚Äù o como me gusta hacer paralelismos con el f√∫tbol, ‚Äújugar para la tribuna‚Äù, pero a fin de cuenta es solo una apariencia.\n¬°Gracias por leerme! üëãüèΩ\n","permalink":"https://luispe.github.io/blog/es/posts/mistakes-and-learnings/","summary":"En nuestra sociedad en general y en tecnolog√≠a en particular tenemos la extra√±a costumbre de publicar los aciertos (opini√≥n de quien redacta, mal llamado caso de √©xito) y pocas, por no decir nulas, las ocasiones donde se comparten los errores (opini√≥n de quien redacta, mal llamado fracaso).\nComo estar√°s sospechando a continuaci√≥n voy a compartir algunos errores, que aprend√≠ de ellos y m√°s a√∫n cuanto crec√≠ y entend√≠ de la industria al compartirlos.","title":"De los errores se aprende, si se comparten, se crece"}]